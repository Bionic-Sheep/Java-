# Java基础知识



# Java面向对象

1、类及类的成员：属性、方法、构造器；代码块、内部类

2、面向对象的三大特征：封装性、继承性、多态性（抽象性）

3、其他关键字。

## 设计类及类的成员

​	属性：对应类的成员变量

​	行为：对应类的成员

### 二、类和对象的使用

​	创建类-->创建类的对象-->通过"对象.属性"调用对象的结构。

一个类可以被创建多个对象，则每个对象拥有类的一套属性。

### 三、属性（成员变量）VS局部变量

**相同点**：

1、定义变量的格式：数据类型  变量名 = 变量值；`int a =  12; `

2、先声明、后定义

3、变量都有对应的作用域

**不同点**：

1、在类中声明的位置不同

​		**属性**直接声明在类{}中

​		**局部变量**声明在方法内、方法形参中、代码块内、构造器形参

2、关于权限修饰符的不同

​		**属性**可以在声明属性时、指明其权限，使用权限修饰符

​		常用的权限修饰符：public , private , 缺省 ， protected :体现被调用时范围大小 -- > 封装性

3、默认初始化值的情况不同

​		**属性**：类的属性根据其类型都有默认的初始化值

​		整型：（long int short byte) 0

​		浮点型：(double float) 0.0

​		字符型：(char) 0|| '\0'

​		boolean: false

​		引用类型：(类、数组、接口) ：null

​		

​		**局部变量**：没有默认初始化值

4、在内存中加载的位置

​		**属性**：加载在堆空间中(非static)

​		**局部变量**：加载在栈空间

### 四、类中的方法声明和使用

​		**方法**：描述类应该有的功能

​		Math类：qsort()\random();

​		声明： 权限修饰符 返回类型 方法名 （形参列表）{ 方法体 }

​		说明：权限修饰符；private、public、缺省、protected -->封装性

​		**返回值类型**

​		方法名：属于标识符，遵循标识符的规则和规范，“见名知意”

​		形参列表：

### 五、方法的重载

​	**重载**：允许方法名相同，但形参列表不同

​	一同两不同：同一类，相同的方法名，参数列表不同；参数个数不同，参数类型不同

​	与权限修饰符、返回值类型，形参变量名，方法体无关

​	在通过对象调用方法时，如何确定一个指定的方法：`方法名 --> 参数列表`

### 六、形参列表及参数不同

**可变形参方法**：

​		1、可变个数形参的格式：`数据类型 ...变量名`

​		2、当调用可变个数形参的方法时，传入的参数个数可以是 0 ，1  ...

​		3、当可变个数形参的方法与本类中的**方法名相同**时，形参不同的方法之间构成重载

​		4、当可变个数形参的方法与本类中的**方法名相同**时，形参**类型**也相同的数组之间不构成重载，即不同共存

```java
public void getSum(string ...strs){}
public void getSum(string[] strs){}//不构成重载
```



​	5、可变个数形参在方法的形参中、必须声明在末尾

```java

public void getSum(int i,String ...strs){}
public void getSum(string...strs，int i){} //可变形参必须放在参数列表末尾，否则可能分不清传递的参数有几个 `
```

​    	6、可变个数形参方法的形参中，最多只能什么一个可变形参，否则分不清传递的参数

**方法参数的值传递机制**

​		1、如果变量是**基本**的数据类型，此时赋值的是变量**保存的数据值**

​		2、如果变量是**引用**的数据类型，此时赋值的变量保存的**数据地址值**

**基本数据类型**

​		值传递时，传入方法的形参会让实参重新开辟内存，所以在方法内做出改变的实参不能影响原来的参数。

**引用数据类型**

​		形参与实参不同，但指向的是同一个堆空间对象，所以在方法内改变能影响原来的形参。

## 构造器

​		**构造器的作用**：创建对象，初始化对象

​		如果没有显式的定义类的构造器的话，则系统默认提供一个空参的构造器

​		定义构造器的格式：权限修饰符 类名 (形参列表) {}

​		一个类中定义的多个构造器，彼此构成重载

​		一旦我们显式的定义类的构造器之后，系统就不在提供默认的空参构造器

```java
public 类名(形参列表){ this.属性 = 形参列表变量 }
```



## this关键词

### 	this的使用

​		1、可以用来修饰：属性、方法、构造器

​		2、this修饰属性和方法

​				this理解为：当前对象和当前正在创建的对象

​				

​				在类的方法中，我们可以使用"this.属性" 和 "this.方法"的方式，调用当前对象属性或方法

​				但是一般来说，我们都选择省略"this"，特殊情况下，如果方法的形参和类的属性同名时，我们必须显式的使用"this.变量"的方式，表明此变量是属性，而非形参

​		3、this调用构造器

​				1、我们在类的构造器中，可以显式的使用"this(形参列表)"，调用本类中指定其他的构造器

​				2、构造器中不能通过"this(形参列表)"方式调用自己

​				3、**规定："this (形参列表)"必须声明在当前构造器的首行**

​				4、构造器内部，最多声明一个"this(形参列表)",用来调用其他的构造器

​				5、如果一个类中有n个构造器，则最多有n-1构造器中使用"this(形参列表)"

```java
public class Test {
	String name;
	int age;
	
	public Test(){
	}
	
	public Test(String name) {
		this.name = name ;
	}
	public Test(String name,int age) {
		this(name);//因为在一个构造器中已经初始化了属性name,所以调用this(形参列表)，避免重复调用。
		this.age = age;
	}
	
}
```



## 面向对象的三特性：

封装性、继承性、多态性

## 封装性

### 问题的引入

当我们创建一个类的对象后，可以通过"对象.属性"的方式，对对象的属性进行赋值，这里的赋值操作会受到属性的数据类型和存储范围的制约，除此之外，没有其他制约条件，但是在实际问题中，我们给属性赋值往往有额外的条件，这个条件就不能再属性声明时体现，只能通过方法进行限制条件的添加。并且回避用户使用"属性.对象"，则将对属性声明为私有的(private)，体现了封装性。

### 封装性的体现

将类的属性私有化，提供公有的方法来设置获取该属性。

```java
private String name;//将类的属性私有化
//设置类属性的方法
public void setNmae(string name){
    this.name = name;
}
//获取类属性的方法
public String getName(String name){
    return this.name;
}
```



## 继承性

### 继承性的好处

​		1、减少代码的冗余

​		2、便于功能的扩展

​		3、为之后多态性使用，提供了前提

### 继承性的格式：class A extends B{}

​		A：子类、派生类、subclass

​		B：父类、超类、基类、superclass



​		2.1体现： 一旦子类A继承父类B以后，子类A就获取了父类B中声明的所有属性、方法

​			特别：父类中声明为pravate的属性、方法，子类继承父类之后，仍然认为获取了父类中私有结构，只是因为封装性的影响，子类不能直接调用父类的结构而已。

​		2.2子类继承父类以后，还可以声明自己特有的属性和方法，实现功能的扩展。

### Java中关于继承性的规定

​		1、一个类可以被多个子类继承

​		2、单继承性：一个类只能有一个父类

​		3、子父类是相对的概念，可以多层继承。

​		4、子类直接继承的父类，称为直接父类，间接继承，称为间接父类

​		5、子类继承父类之后，就获取了直接父类以及所有间接父类中的声明的属性和方法。

# 

### Object类

​		1、如果没有显式的声明一个类的父类的话，则此类继承于java.lang.Object类

​		2、所有的java类（除java.lang.Object之外）都直接或间接的继承与java.lang.Object类

​		3、意味着，所有的java类具有java.lang.Object类声明的功能。



### 方法的重写

​		1、重写：子类继承父类以后，可以对父类中同名同参数的方法，进行覆盖操作

​		2、应用：重写以后，当创建子类对象以后，通过子类对象调用子父类中的同名同参数的方法时，实际执行的是子类重写父类的方法。

​		3、重写的规定：

​					约定俗成：子类叫重写的方法，父类被称为被重写的方法

​				1、子类中重写的方法和父类中被重写的方法方法名和形参列表相同

​				2、子类重写的方法权限修饰符不小于父类中被重写方法的权限修饰符

​								tip：子类不能重写父类中声明为private的方法

​				3、返回值类型：

​								父类被重写的方法返回值类型为void，则子类重写的方法的返回值类型只能是void

​								父类被重写的方法的返回值类型是A类型，则子类重写的方法的返回值类型也是A类或A类的子类

​								父类被重写的方法的返回值类型是基本数据类型（double），则子类重写的方法返回值类型必须是相同的基本数据类型（必须也是double）

​								子类重写的方法抛出的异常类型不大于父类被重写的方法抛出的异常类型。

​				子类父类同名同参数的方法要么需要都声明为非static，要么都是static

### super关键字

​				1.super：理解为：父类的

​				2.super可以用来调用：属性、方法、构造器

​				3.suepr的使用属性和方法

​						3.1 我们可以在子类的方法或构造器中，通过使用"super.属性"或"super.方法"的方式，显式的调用父类中声明的属性或方法，但是，通常情况下，我们习惯省略"super"

​						3.2特殊情况下，当子类父类中定义了同名的属性和方法，需要使用super.来调用父类中的属性和方法。表示调用的是父类中的声明。

​				4.super调用构造器

​						4.1 我们可以在子类的构造器中显式的使用"super(形参列表)"的方式，调用父类中声明的制定构造器

​						4.2"super(形参列表)"的使用，**必须声明在子类构造器的首行**

​						4.3"super()"和"this()"的在构造器中只能使用一种。				

​						4.4当构造器的首行没有显式的声明this和super，则默认调用super(形参列表)。

在类的多个构造器中，至少有一个类的构造器中使用了super(形参列表)，调用父类中的构造器。

### 子类对象实例化过程

​		1.从结果上来看：（继承性）

​				子类继承父类之后，就继承了父类中声明的属性或方法。

​				创建子类的对象，在堆空间中，就会加载所有父类中的声明的属性。

​		2.从过程上来看：

​				当我们通过子类的构造器创建子类对象时，我们一定会**直接或间接的调用其父类的构造器**，进而调用父类的父类的构造器，直到调用了java.lang.Object类中空参的构造器为止。正因为加载过所有父类的结构，所有才看到内存中有父类的结构，子类对象才可以考虑进行调用。						



明确：虽然创建子类对象时，调用了父类的构造器，但是自始至终就创建过一个对象，即为new的子类对象

# 

## 多态性

### 多态的定义

​			1、理解多态性：可以理解为一个事物的多种形态

​			2、何为多态性：

​						对象的多态性：父类的引用指向子类的对象（或子类的对象赋给父类的引用）

​			3、多态的使用：虚拟方法使用

​						有了对象的多态性以后，我们在编译期，只能调用父类中声明的方法，但在运行期，我们实际执行的是子类重写父类的方法。

​						总结：编译，看左边；运行，看右边。

​			4、多态性的使用前提：1.类的继承关系 2.方法的重写

​			5、对象的多态性：跟属性无关，只与方法有关。

```java
//父类
public class Person {}
//子类
public class Man{}
//测试类
public class Test{
    	
    	.....
		
        //对象的多态性：父类的引用指向子类的对象，tip：Many是Person的子类.
		Person p2 = new Man();
		//多态的使用：当调用子类同名同参数的方法时，实际执行的是子类重写父类的方法 --- 虚拟方法调用
		p2.eat();
}
```

### 多态性的使用

​		1、减少了方法的重载，不在编译时绑定函数，有一定的灵活性

```java
public class AnimalTest {
	public static void main(String[] args) {
		AnimalTest animal = new AnimalTest();
		animal.func(new Dog());//创建匿名对象
	}
	public void func(Animal animal) {//如果没有多态性，当需要调用子类中的方法时，需要再写调用子类的方法
		animal.eat();
		animal.shout();
	}
}	

class Animal{
	public void eat() {
		System.out.println("吃东西")；
	}
	public void shout() {
		System.out.println("在叫");
	}
}

class Dog extends Animal{
	public void eat() {
		System.out.println("狗吃东西");
	}
	public void shout() {
		System.out.println("汪汪汪");
	}
}

class Cat extends Animal{
	public void eat() {
		System.out.println("猫吃东西");
	}
	public void shout() {
		System.out.println("喵喵喵");
	}
}
```

# 	

2、不能调用子类所特有的方法、属性：编译时，p2是Person类型。有了对象的多态性之后，内存中实际上是**加载了子类特有的属性和方法**的，但是由于变量声明为**父类类型**，导致编译时，只能**调用父类中的声明的属性和方法**。子类特有的属性和方法不能调用。

​		3、调用子类特有的属性和方法？

​				使用强制类型转换符。(向下转型)

```java
Man m1 = (Man)p2;
m1.earnMoney();

```

​				使用强转时，可能出现ClassCastException的异常

```java
Woman w1 = (Woman)p2;
w1.goShoping();

```

​	用 instanceof关键  a instanceof A ：判断对象a是否是类A的实例。如果是，返回true；如果不是返回false。
使用情境：为了避免在向下转型时出现ClassCastException的异常，我们在向下转型之前，先进行instanceof的判断
一旦返回true就进行向下转型。如果返回false，不进行向下转型。
如果a instanceof A返回true，则a instanceof B 也返回true，其中类B是类A的父亲。

# 	

### Object类的使用

​		1、Object类是所有java类的根父亲

​		2、如果在类的声明中未使用extends关键字指明其父类，则默认父类为java.lang.Object类

​		3、Object类中的功能（属性、方法）就具有通用性。

​				属性：无

​				方法：

​		4、Object类只声明了一个空参的构造器。



###  == 和 equals()的区别

1、==的使用

​		==：运算符

  1. 可以使用在基本数据类型变量和引用数据类型变量

  2. 如果比较的是基本数据类型变量：比较两个变量保存的数据是否相等。（不一定类型要相同）

     如果比较的是引用数据类型变量：比较两个对象的地址值是否相同。即两个引用是否指向同一个对象实体。



2、equals()的使用

1.是方法非运算符

2.只能适用于引用数据类型

3.Object类中equals()的定义：

```java
public boolean equals(Object obj){
		return (this == obj);
}//说明：Object类中定义的equals()和==作用是相同的：比较两个对象的地址值是否相同，即两个引用是否指向同一个地址值
```

4.像String、Date、File、包装类等都重写了Object类中的equals方法。重写以后，比较的不是两个引用的地址是否相同，二十比较两个对象的"实体内容"是否相同。

5.通常情况下，我们自定义的类如果使用equals()的话，也通常是比较两个对象的"实体内容"是否相同。那么我们就需要对Object类中方法进行重写 





### toString()方法

1、当我们输出一个对象的引用时，实际上就是调用当前对象的toString()

2、 Object类中的toString()的定义

```java
	public String toString() {
    return getClass().getName() + "@" + Integer.toHexString(hashCode());
}
```
3、像String、Date等包装类都重写了toString()方法。使得在调用toString()时，返回"实体内容"信息。

4、自定义类也可以重写toString()方法，当调用此方法时，返回对象的"实体内容"。

# 2021.3.8

### 单元测试

单元测试：**测试那块代码就单独测试那块代码**，将待测试的代码块放入测试类

步骤：

1.选中当前工程 - 右键选择：bulid path - add libraries - JUnit 4 - 下一步

2.创建Java类 ，进行单元测试。

​	此时的Java类要求：① 此类是public的 ② 此类提供公共的无参的构造器

3.此类中声明单元测试方法。

​	此时的单元测试方法：方法的权限是public，没有返回值，没有形参



4.此单元测试方法上需要声明注解：@Test，并在单元测试类中导入 import org.junit.Test；

5.声明好单元测试方法以后，就可以在方法体内测试相关的代码。

6.写完代码以后，左键双击单元测试方法名，右键：run as - Junit Test

说明：1.执行结果无异常：绿条

​			2.执行结果异常：红条

```java
public class JUnitTest{

	@Test
	public void testEquals(){
		String s1 = "MM";
		String s2 = "MM";
		System.out.println(s1.equals(s2));
	}
}
```

### 包装类(Wrapper)

包装类(Wrapper)的使用:

1、Java提供了8中基本类型对应的包装类，使得基本类型的变量具有类的特征

2.掌握的：基本数据类型、包装类、String三者之间的相互转换

```java
public class Wrapper {
	//基本数据类型--->包装类：调用包装类的构造器
	@Test
	public void test1() {
		int num1 = 10;
		//System.out.println(num1.toString());
		Integer in1 = new Integer(num1);
		System.out.println(in1.toString());
		
		Integer in2 = new Integer("123");
		System.out.println(in2.toString());
	}
    //包装类--->基本数据类型：调用包装类的XXXValve()
	@Test
	public void test2() {
		Integer in1 = new Integer(12);
		
		int i1 = in1.intValue();
		System.out.println(i1+1);
		
		Float f1 = new Float(12.3);
		float f2 = f1.floatValue();
		System.out.println(f2);
	}
}
```

3.自动装箱和自动拆箱

```java
int num2 = 10;
Integer in1 = num2;//自动装箱

int num3 = in1;//自动拆箱
```



# 2021.3.10

## 关键字static

1.static：静态的

2.static可以用来修饰：属性、方法、代码块、内部类

3.使用static修饰属性：修饰的叫静态变量

​			3.1属性：按是否使用static修饰。又分为：静态属性  VS 非 静态变量（实例变量）

​			实列变量：我们创建了类的多个对象，每个对象都独立拥有一套类中的非静态属性。当修改其中一个对象中的非静态属性时，不会导致其他对象中同样的属性值的修改。

​			静态变量：我们创建了类的多个对象，多个对象共享同一个静态变量。当通过某一个对象修改静态变量时，会导致其他对象调用此静态变量时，是修改过了的。

​			3.2 static修饰属性的其他说明：

​					① 静态变量随着类的加载而加载，可以通过“类.静态变量"的方式进行调用

​					② 静态变量的加载要早于对象的创建

​					③ 由于类只会加载一次，则静态变量在内存中也只会存在一份：存在方法区的静态域中。

​					④ 类能调用静态变量，不能调用实例变量，对象都可以

4.使用static修饰方法：静态方法

​					① 随着类的加载而加载，可以 通过"类.静态方法"的方式进行调用

​					② 类能调用静态方法，不能调用非静态方法，对象都可以

​					③ 静态方法中，只能调用静态的方法或属性，非静态的方法中，非静态方法中，非静态和静态的方法属性都可以调用

5.static注意点

​	5.1 在静态的方法内，不能使用this关键字，super关键字

​	5.2 关于静态属性和静态方法的使用，从生命周期的角度去理解。

6.如何确定一个属性是否被声明为static：当该属性被多个对象使用，不随着对象的变化而变化

​	如何确定一个方法是否被声明为static：操作静态属性的方法，通常设置为static的 。 工具类中的方法，习惯上声明为static的。比如： Math，Arrays、Collections 。 

7.static的应用

```java
public class Circle {
	public static void main(String[] args) {
		Cir c1 = new Cir();
		Cir c2 = new Cir();
		
		System.out.println("c1的id： " + c1.getId());
		System.out.println("c2的id： " + c2.getId());
	}
}

class Cir{
	//创建类 在创建类的对象和属性
	private double radius;
	private int id;
    
	private static int init = 1000;//静态变量
	
	public Cir() {
		id = init++;//static创建的属性变量被所有对象共享
	}

	public int getId() {
		return id;
	}

	public void setId(int id) {
		this.id = id;
	}
}
```



# 2021.3.11

## 单例设计模式

饿汉式：坏处：对象加载时间过长 好处；是线程安全的
懒汉式：好处：延迟对象的加载 坏处：目前写法线程不安全。

```java

1.饿汉式
class Bank{
	//1.私有化类的构造器
	private Bank() {
		
	}
	//2.内部创建类的对象，要求此对象也必须声明为静态的
	private static Bank instance = new Bank();
	//4.提供公共的静态的方法，返回类的对象。
	public static Bank getInstance() {
		return instance;
	}
}
2、懒汉式
class Order{
	//1.私有化类的构造器
	private Order() {
		
	}
	//2.声明当前类的对象，没有初始化,也必须声明为static
	private static Order instance = null;
	//3.声明public、static的返回当前类对象的方法
	public static Order getInstance() {
		if(instance == null) {
			instance = new Order();
		}
		return instance;
	}
}

```

应用场景：

网站的计数器、应用程序的日志应用、数据库连接池。

## 抽象类

用abstract关键字修饰类：抽象类/修饰方法：抽象方法

```java
public abstract void talk();
```

抽象类**不能被实例化**，用来被继承的，抽象类的子类必须**重写**父类的抽象方法，**提供方法体**。若没有重写全部抽象方法，仍为抽象类。

TIP: 不能用abstract修饰变量、代码块、构造器；私有方法，静态方法，final的方法，final的类。

当子类一定要重写时，可以抽象化类

# 2021.3.12

## 接口

从多个类中派生出子类，继承所有的属性和方法，有了接口就可以多重继承。

### 接口的使用

​	1.接口使用interface来定义

​	2.JAVA中，接口和类是并列的两个结构

​	3.如何定义接口：定义接口中的成员

​			3.1 JDK7及以前：只能定义全局常量和抽象方法

​			>全局常量： public static final的 书写时，可以省略

​			>抽象方法： public anstract的

​			

​			3.2 JDK8：增加了静态方法，默认方法

4.接口中不能定义构造器，意味着接口不可以实例化

5.java开发中，接口通过让类去实现(implements)接口

​		如果实现类覆盖了接口总所有的抽象方法，则该实现类可以实例化

​		如果实现类没有覆盖所有的抽象方法，则该实现类仍为一个抽象类

6.java类可以实现多个接口  --->弥补java单继承性的局限性



## 接口和抽象类的对比

|      |    区别点    |                  抽象类                  |                  接口                  |
| :--: | :----------: | :--------------------------------------: | :------------------------------------: |
|  1   |     定义     |             包含抽象方法的类             |     主要是抽象方法和全局常量的集合     |
|  2   |     组成     | 构成方法、抽象方法、普通方法、常量、变量 |             常量、抽象方法             |
|  3   |     关系     |          抽象类可以实现多个接口          | 接口不能继承抽象类，但运行继承多个接口 |
|  4   | 常见设计模式 |                 模板方法                 |      简单工厂、工程方法、代理模式      |
|  5   |     对象     |      通过对象的多态性产生实例化对象      |     通过对象的多态性产生实例化对象     |
|  6   |     局限     |           抽象类有单继承的局限           |             接口没有此局限             |
|  7   |     实际     |                 作为模板                 |     是作为一个标准或是表示一种能力     |
|  8   |     使用     |              子类继承抽象类              |              子类实现接口              |
|  9   |     选择     |        优先使用接口，避免单继承性        |       优先使用接口，避免单继承性       |



## 内部类

​	当允许一个类的定义位于另一个类的内部，前者为**内部类**，后者为**外部类**。

​	定义： class Inner{...} 

成员内部类作为类的成员的角色

​	1.Inner class 还可以声明为private 或protected

​	2.可以调用外部类的结构

​	3.可以声明为static的 但此时就不能再使用外层类的非static的成员变量

成员内部类作为类的角色

​	1.可以在内部定义属性、方法、构造器等结构

​	2.可以声明为abstract类，因此可以被其他的内部类继承

​	3.可以声明在final的

​	4.编译后生成OuterClass&InnerClass.class字节码文件

tip:

1.非static的成员内部类中的成员不能声明为static的，只有在外部类或static的成员内部类中才可声明static成员

2.外部类访问成员类的成员，需要内部类.成员或内部类对象.成员的方式

3.成员内部类可以直接使用外部类的所有成员，包括私有的数据

4.当想要在外部类的静态成员部分使用内部类时，可以考虑内部类声明为静态的



局部内部类的声明

```java
class 外部类{
	方法(){
		class 局部内部类{
		}
	}
	{
		class 局部内部类{
		}
	}
}
```

使用方法：

1.只能在声明它的方法或代码块中使用，而且是先声明后使用。除此之外的任何地方都不能使用该类

2.但是它的对象可以通过外部方法的返回值返回使用，返回值类型只能是局部内部类的父类或父接口类型

## 匿名内部类

不定义任何静态成员、方法和类，只能创建匿名内部类的一个实例，一个匿名内部类一定是再new后面，用其隐含实现一个接口或实现一个类

```java
new 父类构造器（实参列表）|实现接口（）{
	//匿名内部类的类体部分
}
```

特点：

​	1.必须继承父类或实现接口

​	2.只能有一个对象

​	3.匿名内部类对象只能使用多态形式引用

```java
interface A{
	public abtract void fun1();
}
public class Outer{
	public static void main(String[] args){
		new Outer().calllnner(new A(){//接口是不能new但此处比较特殊是子类对象实现接口，只不过没有为对象去取名
			public void fun1(){
				System.out.println("implement for fun1");
			}
				});//两步写成一步	
		}
		public void callnner(A a){
			a.func1();
		}
	}
}
```



# 异常处理

异常：将程序执行中发生的不正常情况称为“异常”

异常处理：抓抛模型

  过程一：“抛”：程序在正常执行过程中，一旦出现异常，就会在异常代码处生成一个对应异常类的对象
  				并将此对象抛出。
  				一旦抛出对象以后，其后的代码就不再执行。

  过程二：“抓”：可以理解为异常的处理方式：① try - catch - fianlly ② throws

  二、try - catch -finally 的使用
  		try{
  		//可能出现的异常代码
  }catch(异常类型1 变量名1）{
  	//处理异常的方式1
  }catch（异常类型2 变量名2){
 	//处理异常的方式2 	
 }	
 ...
 finally{
  //一定会执行的代码
  }
 	1.finally是可选的。
 	2. 使用try将可能出现的异常代码包装起来，在执行过程中，一旦出现异常，就会生成一个对应异常类的
 		对象，根据此对象的类型，去catch中进行匹配
 	3.一旦try中的异常对象匹配到某一个catch时，就会进入catch中进行异常的处理，一旦处理完成，就跳出当前的try-catch结构
 		（在没有写finally的情况）。继续执行其后的代码
 	4.catch中的异常类型如果没有子父类关系，则谁声明在上，谁声明在下无所谓。
 		catch中的异常类型如果满足子父类关系，则要求子类一定声明在父类的上面，否则，报错。
 	5.常用的异常对象处理方式： ① String getMessage() ② printStackTrace() 
 	6.在try结构中声明的变量，在出了try结构以后，就不能再被调用
 	
 体会：使用try - catch - finlly处理编译时异常，使得程序在编译时就不再报错，但运行时仍可能出错，
 		相当于我们使用try -catch - finally将一个编译时可能出现的异常，延迟到运行时出现。

​			

​		





 